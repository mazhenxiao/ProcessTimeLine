"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Apply_1 = require("./Apply");
var Option_1 = require("./Option");
var Semigroup_1 = require("./Semigroup");
var function_1 = require("./function");
exports.URI = 'StrMap';
/**
 * @data
 * @constructor StrMap
 * @since 1.0.0
 */
var StrMap = /** @class */ (function () {
    function StrMap(value) {
        this.value = value;
    }
    StrMap.prototype.mapWithKey = function (f) {
        var o = this.value;
        var r = {};
        for (var k in o) {
            r[k] = f(k, o[k]);
        }
        return new StrMap(r);
    };
    StrMap.prototype.map = function (f) {
        return this.mapWithKey(function (_, a) { return f(a); });
    };
    StrMap.prototype.reduce = function (b, f) {
        var out = b;
        var value = this.value;
        var keys = Object.keys(value).sort();
        var len = keys.length;
        for (var i = 0; i < len; i++) {
            out = f(out, value[keys[i]]);
        }
        return out;
    };
    /**
     * @since 1.4.0
     */
    StrMap.prototype.filter = function (p) {
        var o = this.value;
        var r = {};
        for (var k in o) {
            var value = o[k];
            if (p(value)) {
                r[k] = value;
            }
        }
        return new StrMap(r);
    };
    return StrMap;
}());
exports.StrMap = StrMap;
var empty = new StrMap({});
var concat = function (S) {
    var concat = Semigroup_1.getDictionarySemigroup(S).concat;
    return function (x, y) { return new StrMap(concat(x.value, y.value)); };
};
var concatCurried = function (S) {
    var concatS = concat(S);
    return function (x) { return function (y) { return concatS(x, y); }; };
};
/**
 * @function
 * @since 1.0.0
 */
exports.getMonoid = function (S) {
    if (S === void 0) { S = Semigroup_1.getLastSemigroup(); }
    return {
        concat: concat(S),
        empty: empty
    };
};
var map = function (fa, f) {
    return fa.map(f);
};
var reduce = function (fa, b, f) {
    return fa.reduce(b, f);
};
/**
 * @function
 * @since 1.0.0
 */
function traverseWithKey(F) {
    return function (ta, f) {
        var concatA2 = Apply_1.liftA2(F)(concatCurried(Semigroup_1.getLastSemigroup()));
        var out = F.of(empty);
        var _loop_1 = function (k) {
            out = concatA2(out)(F.map(f(k, ta.value[k]), function (b) { return exports.singleton(k, b); }));
        };
        for (var k in ta.value) {
            _loop_1(k);
        }
        return out;
    };
}
exports.traverseWithKey = traverseWithKey;
function traverse(F) {
    return function (ta, f) { return traverseWithKey(F)(ta, function (_, a) { return f(a); }); };
}
/**
 * Test whether one dictionary contains all of the keys and values contained in another dictionary
 * @function
 * @since 1.0.0
 */
exports.isSubdictionary = function (S) { return function (d1, d2) {
    for (var k in d1.value) {
        if (!d2.value.hasOwnProperty(k) || !S.equals(d1.value[k], d2.value[k])) {
            return false;
        }
    }
    return true;
}; };
/**
 * Calculate the number of key/value pairs in a dictionary
 * @function
 * @since 1.0.0
 */
exports.size = function (d) {
    return Object.keys(d.value).length;
};
/**
 * Test whether a dictionary is empty
 * @function
 * @since 1.0.0
 */
exports.isEmpty = function (d) {
    for (var _ in d.value) {
        return false;
    }
    return true;
};
/**
 * @function
 * @since 1.0.0
 */
exports.getSetoid = function (S) {
    var isSubdictionaryS = exports.isSubdictionary(S);
    return {
        equals: function (x, y) { return isSubdictionaryS(x, y) && isSubdictionaryS(y, x); }
    };
};
/**
 * Create a dictionary with one key/value pair
 * @function
 * @since 1.0.0
 */
exports.singleton = function (k, a) {
    return new StrMap((_a = {}, _a[k] = a, _a));
    var _a;
};
/**
 * Lookup the value for a key in a dictionary
 * @function
 * @since 1.0.0
 */
exports.lookup = function (k, d) {
    return d.value.hasOwnProperty(k) ? Option_1.some(d.value[k]) : Option_1.none;
};
/**
 * Create a dictionary from a foldable collection of key/value pairs, using the
 * specified function to combine values for duplicate keys.
 * @function
 * @since 1.0.0
 */
function fromFoldable(F) {
    return function (ta, f) {
        return F.reduce(ta, new StrMap({}), function (b, a) {
            var k = a[0];
            b.value[k] = b.value.hasOwnProperty(k) ? f(b.value[k], a[1]) : a[1];
            return b;
        });
    };
}
exports.fromFoldable = fromFoldable;
/**
 * @function
 * @since 1.0.0
 */
exports.collect = function (d, f) {
    var out = [];
    for (var k in d.value) {
        out.push(f(k, d.value[k]));
    }
    return out;
};
/**
 * @function
 * @since 1.0.0
 */
exports.toArray = function (d) {
    return exports.collect(d, function (k, a) { return function_1.tuple(k, a); });
};
/**
 * Unfolds a dictionary into a list of key/value pairs
 * @function
 * @since 1.0.0
 */
exports.toUnfoldable = function (unfoldable) { return function (d) {
    var arr = exports.toArray(d);
    var len = arr.length;
    return unfoldable.unfoldr(0, function (b) { return (b < len ? Option_1.some(function_1.tuple(arr[b], b + 1)) : Option_1.none); });
}; };
/**
 * Insert or replace a key/value pair in a map
 * @function
 * @since 1.0.0
 */
exports.insert = function (k, a, d) {
    var copy = Object.assign({}, d.value);
    copy[k] = a;
    return new StrMap(copy);
};
/**
 * Delete a key and value from a map
 * @function
 * @since 1.0.0
 */
exports.remove = function (k, d) {
    var copy = Object.assign({}, d.value);
    delete copy[k];
    return new StrMap(copy);
};
/**
 * Delete a key and value from a map, returning the value as well as the subsequent map
 * @function
 * @since 1.0.0
 */
exports.pop = function (k, d) {
    var a = exports.lookup(k, d);
    return a.isNone() ? Option_1.none : Option_1.some(function_1.tuple(a.value, exports.remove(k, d)));
};
/**
 * @instance
 * @since 1.0.0
 */
exports.strmap = {
    URI: exports.URI,
    map: map,
    reduce: reduce,
    traverse: traverse
};
//# sourceMappingURL=StrMap.js.map