"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Array_1 = require("./Array");
var Option_1 = require("./Option");
var Semigroup_1 = require("./Semigroup");
var function_1 = require("./function");
exports.URI = 'NonEmptyArray';
/**
 * Data structure which represents non-empty arrays
 * @data
 * @constructor NonEmptyArray
 * @since 1.0.0
 */
var NonEmptyArray = /** @class */ (function () {
    function NonEmptyArray(head, tail) {
        this.head = head;
        this.tail = tail;
    }
    /**
     * Converts this {@link NonEmptyArray} to plain {@link Array}
     * @since 1.0.0
     * @example
     * assert.deepEqual(new NonEmptyArray(1, [2, 3]), [1, 2, 3])
     * @returns {Array<A>} foo
     */
    NonEmptyArray.prototype.toArray = function () {
        return function_1.concat([this.head], this.tail);
    };
    /**
     * Concatenates this {@link NonEmptyArray} and passed {@link Array}
     * @since 1.0.0
     * @param {Array<A>} as - {@link Array}
     * @example
     * assert.deepEqual(new NonEmptyArray(1, []).concatArray([2]), new NonEmptyArray(1, [2]))
     * @returns {NonEmptyArray<A>}
     */
    NonEmptyArray.prototype.concatArray = function (as) {
        return new NonEmptyArray(this.head, function_1.concat(this.tail, as));
    };
    /**
     * Instance-bound implementation of {@link Functor}
     * @since 1.0.0
     * @param {(a: A) => B} f
     * @example
     * const double = (n: number): number => n * 2
     * assert.deepEqual(new NonEmptyArray(1, [2]).map(double), new NonEmptyArray(2, [4]))
     * @returns {NonEmptyArray<B>}
     */
    NonEmptyArray.prototype.map = function (f) {
        return new NonEmptyArray(f(this.head), this.tail.map(f));
    };
    /**
     * Instance-bound implementation of {@link Apply}
     * @since 1.0.0
     * @param {NonEmptyArray<(a: A) => B>} fab
     * @example
     * const x = new NonEmptyArray(1, [2])
     * const double = (n: number) => n * 2
     * assert.deepEqual(x.ap(new NonEmptyArray(double, [double])).toArray(), [2, 4, 2, 4])
     * @returns {NonEmptyArray<B>}
     */
    NonEmptyArray.prototype.ap = function (fab) {
        var _this = this;
        return fab.chain(function (f) { return _this.map(f); }); // <= derived
    };
    /**
     * Same as {@link ap} but works on {@link NonEmptyArray} of functions and accepts {@link NonEmptyArray} of values instead
     * @since 1.0.0
     * @this {NonEmptyArray<(b: B) => C>}
     * @param {NonEmptyArray<B>} fb
     * @example
     * const x = new NonEmptyArray(1, [2])
     * const double = (n: number) => n * 2
     * assert.deepEqual(new NonEmptyArray(double, [double]).ap_(x).toArray(), [2, 4, 2, 4])
     * @returns {NonEmptyArray<C>}
     */
    NonEmptyArray.prototype.ap_ = function (fb) {
        return fb.ap(this);
    };
    /**
     * Instance-bound implementation of {@link Chain}
     * @since 1.0.0
     * @param {(a: A) => NonEmptyArray<B>} f
     * @example
     * const x = new NonEmptyArray(1, [2])
     * const f = (a: number) => new NonEmptyArray(a, [4])
     * assert.deepEqual(x.chain(f).toArray(), [1, 4, 2, 4])
     * @returns {NonEmptyArray<B>}
     */
    NonEmptyArray.prototype.chain = function (f) {
        return f(this.head).concatArray(Array_1.array.chain(this.tail, function (a) { return f(a).toArray(); }));
    };
    /**
     * Instance-bound implementation of {@link Semigroup}
     * @since 1.0.0
     * @param {NonEmptyArray<A>} y
     * @example
     * const x = new NonEmptyArray(1, [2])
     * const y = new NonEmptyArray(3, [4])
     * assert.deepEqual(x.concat(y).toArray(), [1, 2, 3, 4])
     * @returns {NonEmptyArray<A>}
     */
    NonEmptyArray.prototype.concat = function (y) {
        return this.concatArray(y.toArray());
    };
    /**
     * Instance-bound implementation of {@link Foldable}
     * @since 1.0.0
     * @param {B} b
     * @param {(b: B, a: A) => B} f
     * @example
     * const x = new NonEmptyArray('a', ['b'])
     * assert.strictEqual(x.reduce('', (b, a) => b + a), 'ab')
     * @returns {B}
     */
    NonEmptyArray.prototype.reduce = function (b, f) {
        return Array_1.array.reduce(this.toArray(), b, f);
    };
    /**
     * Instance-bound implementation of {@link Extend}
     * @since 1.0.0
     * @param {(fa: NonEmptyArray<A>) => B} f
     * @example
     * const sum = (as: NonEmptyArray<number>) => fold(monoidSum)(as.toArray())
     * assert.deepEqual(new NonEmptyArray(1, [2, 3, 4]).extend(sum), new NonEmptyArray(10, [9, 7, 4]))
     * @returns {NonEmptyArray<B>}
     */
    NonEmptyArray.prototype.extend = function (f) {
        return unsafeFromArray(Array_1.array.extend(this.toArray(), function (as) { return f(unsafeFromArray(as)); }));
    };
    /**
     * Instance-bound implementation of {@link Comonad}
     * @since 1.0.0
     * @example
     * assert.strictEqual(new NonEmptyArray(1, [2, 3]).extract(), 1)
     * @returns {A}
     */
    NonEmptyArray.prototype.extract = function () {
        return this.head;
    };
    /**
     * Same as {@link toString}
     * @since 1.0.0
     * @returns {string}
     */
    NonEmptyArray.prototype.inspect = function () {
        return this.toString();
    };
    /**
     * Return stringified representation of this {@link NonEmptyArray}
     * @since 1.0.0
     * @returns {string}
     */
    NonEmptyArray.prototype.toString = function () {
        return "new NonEmptyArray(" + function_1.toString(this.head) + ", " + function_1.toString(this.tail) + ")";
    };
    /**
     * Gets minimum of this {@link NonEmptyArray} using specified {@link Ord} instance
     * @since 1.3.0
     * @param ord - {@link Ord} instance
     * @example
     * const minimum = new NonEmptyArray(1, [2, 3]).min(ordNumber) // 1
     * @returns {A}
     */
    NonEmptyArray.prototype.min = function (ord) {
        return Semigroup_1.fold(Semigroup_1.getMeetSemigroup(ord))(this.head)(this.tail);
    };
    /**
     * Gets maximum of this {@link NonEmptyArray} using specified {@link Ord} instance
     * @since 1.3.0
     * @param ord - {@link Ord} instance
     * @example
     * const maximum = new NonEmptyArray(1, [2, 3]).max(ordNumber) // 3
     * @returns {A}
     */
    NonEmptyArray.prototype.max = function (ord) {
        return Semigroup_1.fold(Semigroup_1.getJoinSemigroup(ord))(this.head)(this.tail);
    };
    /**
     * Gets last element of this {@link NonEmptyArray}
     * @since 1.6.0
     * @example
     * const last = new NonEmptyArray(1, [2, 3]).last(); // 3
     * const last = new NonEmptyArray(1, []).last(); // 1
     * @returns {A}
     */
    NonEmptyArray.prototype.last = function () {
        return Array_1.last(this.tail).getOrElse(this.head);
    };
    /**
     * Sorts this {@link NonEmptyArray} using specified {@link Ord} instance
     * @since 1.6.0
     * @param {Ord<A>} ord - {@link Ord} instance
     * @example
     * const result = new NonEmptyArray(3, [2, 1]).sort(ordNumber)
     * const expected = new NonEmptyArray(1, [2, 3])
     * assert.deepEqual(result, expected)
     * @returns {NonEmptyArray<A>}
     */
    NonEmptyArray.prototype.sort = function (ord) {
        return unsafeFromArray(Array_1.sort(ord)(this.toArray()));
    };
    /**
     * Reverts this {@link NonEmptyArray}
     * @since 1.6.0
     * @example
     * const result = new NonEmptyArray(1, [2, 3]).reverse()
     * const expected = new NonEmptyArray(3, [2, 1])
     * assert.deepEqual(result, expected)
     * @returns {NonEmptyArray<A>}
     */
    NonEmptyArray.prototype.reverse = function () {
        return unsafeFromArray(this.toArray().reverse());
    };
    return NonEmptyArray;
}());
exports.NonEmptyArray = NonEmptyArray;
var unsafeFromArray = function (as) {
    return new NonEmptyArray(as[0], as.slice(1));
};
/**
 * Builds {@link NonEmptyArray} from {@link Array} returning {@link Option#none} or {@link Option#some} depending on amount of values in passed array
 * @function
 * @since 1.0.0
 * @param {Array<A>} as
 * @returns {Option<NonEmptyArray<A>>}
 */
exports.fromArray = function (as) {
    return as.length > 0 ? Option_1.some(unsafeFromArray(as)) : Option_1.none;
};
var map = function (fa, f) {
    return fa.map(f);
};
var of = function (a) {
    return new NonEmptyArray(a, []);
};
var ap = function (fab, fa) {
    return fa.ap(fab);
};
var chain = function (fa, f) {
    return fa.chain(f);
};
var concat = function (fx, fy) {
    return fx.concat(fy);
};
/**
 * Builds {@link Semigroup} instance for {@link NonEmptyArray} of specified type arument
 * @function
 * @since 1.0.0
 * @returns {Semigroup<NonEmptyArray<A>>}
 */
exports.getSemigroup = function () {
    return { concat: concat };
};
var reduce = function (fa, b, f) {
    return fa.reduce(b, f);
};
var extend = function (fa, f) {
    return fa.extend(f);
};
var extract = function (fa) {
    return fa.extract();
};
function traverse(F) {
    return function (ta, f) { return F.map(Array_1.array.traverse(F)(ta.toArray(), f), unsafeFromArray); };
}
/**
 * @instance
 * @since 1.0.0
 */
exports.nonEmptyArray = {
    URI: exports.URI,
    extend: extend,
    extract: extract,
    map: map,
    of: of,
    ap: ap,
    chain: chain,
    reduce: reduce,
    traverse: traverse
};
//# sourceMappingURL=NonEmptyArray.js.map