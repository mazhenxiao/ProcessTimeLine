import { Alternative1 } from './Alternative';
import { Applicative, Applicative1, Applicative2, Applicative2C, Applicative3, Applicative3C } from './Applicative';
import { Either } from './Either';
import { Extend1 } from './Extend';
import { Foldable1 } from './Foldable';
import { HKT, Type, Type2, Type3, URIS, URIS2, URIS3 } from './HKT';
import { Monad1 } from './Monad';
import { Monoid } from './Monoid';
import { Option } from './Option';
import { Ord } from './Ord';
import { Plus1 } from './Plus';
import { Setoid } from './Setoid';
import { Traversable1 } from './Traversable';
import { Unfoldable1 } from './Unfoldable';
import { Endomorphism, Predicate, Refinement } from './function';
declare global  {
    interface Array<T> {
        _URI: URI;
        _A: T;
    }
}
declare module './HKT' {
    interface URI2HKT<A> {
        Array: Array<A>;
    }
}
export declare const URI = "Array";
export declare type URI = typeof URI;
/**
 * @function
 * @since 1.0.0
 */
export declare const getMonoid: <A = never>() => Monoid<A[]>;
/**
 * Derives a Setoid over the Array of a given element type from the Setoid of that type. The derived setoid defines two
 * arrays as equal if all elements of both arrays are compared equal pairwise with the given setoid 'S'. In case of
 * arrays of different lengths, the result is non equality.
 *
 * @constant
 * @since 1.0.0
 */
export declare const getSetoid: <A>(S: Setoid<A>) => Setoid<A[]>;
/**
 * Derives an Order over the Array of a given element type from the Order, 'O', of that type. The ordering between two
 * such arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order,
 * in case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have
 * the same length, the result is equality.
 *
 * @function
 * @since 1.2.0
 */
export declare const getOrd: <A>(O: Ord<A>) => Ord<A[]>;
export declare function traverse<F extends URIS3>(F: Applicative3<F>): <U, L, A, B>(ta: Array<A>, f: (a: A) => Type3<F, U, L, B>) => Type3<F, U, L, Array<B>>;
export declare function traverse<F extends URIS3, U, L>(F: Applicative3C<F, U, L>): <A, B>(ta: Array<A>, f: (a: A) => Type3<F, U, L, B>) => Type3<F, U, L, Array<B>>;
export declare function traverse<F extends URIS2>(F: Applicative2<F>): <L, A, B>(ta: Array<A>, f: (a: A) => Type2<F, L, B>) => Type2<F, L, Array<B>>;
export declare function traverse<F extends URIS2, L>(F: Applicative2C<F, L>): <A, B>(ta: Array<A>, f: (a: A) => Type2<F, L, B>) => Type2<F, L, Array<B>>;
export declare function traverse<F extends URIS>(F: Applicative1<F>): <A, B>(ta: Array<A>, f: (a: A) => Type<F, B>) => Type<F, Array<B>>;
export declare function traverse<F>(F: Applicative<F>): <A, B>(ta: Array<A>, f: (a: A) => HKT<F, B>) => HKT<F, Array<B>>;
/**
 * @function
 * @since 1.0.0
 */
export declare const partitionMap: <A, L, R>(fa: A[], f: (a: A) => Either<L, R>) => {
    left: L[];
    right: R[];
};
/**
 * @example
 * flatten([[1], [2], [3]]) // [1, 2, 3]
 *
 * @function
 * @since 1.0.0
 */
export declare const flatten: <A>(ffa: A[][]) => A[];
/**
 * Break an array into its first element and remaining elements
 * @function
 * @since 1.0.0
 */
export declare const fold: <A, B>(as: A[], b: B, cons: (head: A, tail: A[]) => B) => B;
/**
 * Lazy version of `fold`
 * @function
 * @since 1.0.0
 */
export declare const foldL: <A, B>(as: A[], nil: () => B, cons: (head: A, tail: A[]) => B) => B;
/**
 * Same as `reduce` but it carries over the intermediate steps
 *
 * ```ts
 * scanLeft([1, 2, 3], 10, (b, a) => b - a) // [ 10, 9, 7, 4 ]
 * ```
 *
 * @function
 * @since 1.1.0
 */
export declare const scanLeft: <A, B>(as: A[], b: B, f: (b: B, a: A) => B) => B[];
/**
 * Fold an array from the right, keeping all intermediate results instead of only the final result
 *
 * ```ts
 * scanRight([1, 2, 3], 10, (a, b) => b - a) // [ 4, 5, 7, 10 ]
 * ```
 *
 * @function
 * @since 1.1.0
 */
export declare const scanRight: <A, B>(as: A[], b: B, f: (a: A, b: B) => B) => B[];
/**
 * Test whether an array is empty
 * @function
 * @since 1.0.0
 */
export declare const isEmpty: <A>(as: A[]) => boolean;
/**
 * Test whether an array contains a particular index
 * @function
 * @since 1.0.0
 */
export declare const isOutOfBound: <A>(i: number, as: A[]) => boolean;
/**
 * This function provides a safe way to read a value at a particular index from an array
 * @function
 * @since 1.0.0
 */
export declare const index: <A>(i: number, as: A[]) => Option<A>;
/**
 * Attaches an element to the front of an array, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const cons: <A>(a: A, as: A[]) => A[];
/**
 * Append an element to the end of an array, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const snoc: <A>(as: A[], a: A) => A[];
/**
 * Get the first element in an array, or `None` if the array is empty
 * @function
 * @since 1.0.0
 */
export declare const head: <A>(as: A[]) => Option<A>;
/**
 * Get the last element in an array, or `None` if the array is empty
 * @function
 * @since 1.0.0
 */
export declare const last: <A>(as: A[]) => Option<A>;
/**
 * Get all but the first element of an array, creating a new array, or `None` if the array is empty
 * @function
 * @since 1.0.0
 */
export declare const tail: <A>(as: A[]) => Option<A[]>;
/**
 * Get all but the last element of an array, creating a new array, or `None` if the array is empty
 * @function
 * @since 1.0.0
 */
export declare const init: <A>(as: A[]) => Option<A[]>;
/**
 * Keep only a number of elements from the start of an array, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const take: <A>(n: number, as: A[]) => A[];
/**
 * Split an array into two parts:
 * 1. the longest initial subarray for which all elements satisfy the specified predicate
 * 2. the remaining elements
 * @function
 * @since 1.0.0
 */
export declare const span: <A>(as: A[], predicate: Predicate<A>) => {
    init: A[];
    rest: A[];
};
/**
 * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const takeWhile: <A>(as: A[], predicate: Predicate<A>) => A[];
/**
 * Drop a number of elements from the start of an array, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const drop: <A>(n: number, as: A[]) => A[];
/**
 * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const dropWhile: <A>(as: A[], predicate: Predicate<A>) => A[];
/**
 * Find the first index for which a predicate holds
 * @function
 * @since 1.0.0
 */
export declare const findIndex: <A>(as: A[], predicate: Predicate<A>) => Option<number>;
/**
 * Find the first element which satisfies a predicate function
 * @function
 * @since 1.0.0
 */
export declare const findFirst: <A>(as: A[], predicate: Predicate<A>) => Option<A>;
/**
 * Find the last element which satisfies a predicate function
 * @function
 * @since 1.0.0
 */
export declare const findLast: <A>(as: A[], predicate: Predicate<A>) => Option<A>;
/**
 * Filter an array, keeping the elements which satisfy a predicate function, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const filter: <A>(as: A[], predicate: Predicate<A>) => A[];
/**
 * @function
 * @since 1.0.0
 */
export declare const refine: <A, B extends A>(as: A[], refinement: Refinement<A, B>) => B[];
/**
 * @function
 * @since 1.0.0
 */
export declare const copy: <A>(as: A[]) => A[];
/**
 * @function
 * @since 1.0.0
 */
export declare const unsafeInsertAt: <A>(i: number, a: A, as: A[]) => A[];
/**
 * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds
 * @function
 * @since 1.0.0
 */
export declare const insertAt: <A>(i: number, a: A, as: A[]) => Option<A[]>;
/**
 * @function
 * @since 1.0.0
 */
export declare const unsafeUpdateAt: <A>(i: number, a: A, as: A[]) => A[];
/**
 * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
 * @function
 * @since 1.0.0
 */
export declare const updateAt: <A>(i: number, a: A, as: A[]) => Option<A[]>;
/**
 * @function
 * @since 1.0.0
 */
export declare const unsafeDeleteAt: <A>(i: number, as: A[]) => A[];
/**
 * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
 * @function
 * @since 1.0.0
 */
export declare const deleteAt: <A>(i: number, as: A[]) => Option<A[]>;
/**
 * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out
 * of bounds
 * @function
 * @since 1.0.0
 */
export declare const modifyAt: <A>(as: A[], i: number, f: Endomorphism<A>) => Option<A[]>;
/**
 * Reverse an array, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const reverse: <A>(as: A[]) => A[];
/**
 * Apply a function to each element in an array, keeping only the results
 * which contain a value, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const mapOption: <A, B>(as: A[], f: (a: A) => Option<B>) => B[];
/**
 * Filter an array of optional values, keeping only the elements which contain a value, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const catOptions: <A>(as: Option<A>[]) => A[];
/**
 * Extracts from a list of `Either` all the `Right` elements. All the `Right` elements are extracted in order
 * @function
 * @since 1.0.0
 */
export declare const rights: <L, A>(as: Either<L, A>[]) => A[];
/**
 * Extracts from a list of `Either` all the `Left` elements. All the `Left` elements are extracted in order
 * @function
 * @since 1.0.0
 */
export declare const lefts: <L, A>(as: Either<L, A>[]) => L[];
/**
 * Sort the elements of an array in increasing order, creating a new array
 * @function
 * @since 1.0.0
 */
export declare const sort: <A>(O: Ord<A>) => (as: A[]) => A[];
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one
 * input array is short, excess elements of the longer array are discarded.
 * @function
 * @since 1.0.0
 */
export declare const zipWith: <A, B, C>(fa: A[], fb: B[], f: (a: A, b: B) => C) => C[];
/**
 * Takes two arrays and returns an array of corresponding pairs. If one input array is short, excess elements of the
 * longer array are discarded
 * @function
 * @since 1.0.0
 */
export declare const zip: <A, B>(fa: A[], fb: B[]) => [A, B][];
/**
 * Rotate an array to the right by `n` steps
 * @function
 * @since 1.0.0
 */
export declare const rotate: <A>(n: number, xs: A[]) => A[];
/**
 * Test if a value is a member of an array
 * @function
 * @since 1.3.0
 */
export declare const member: <A>(S: Setoid<A>) => (as: A[], a: A) => boolean;
/**
 * Remove duplicates from an array, keeping the first occurance of an element.
 * @function
 * @since 1.3.0
 */
export declare const uniq: <A>(S: Setoid<A>) => (as: A[]) => A[];
/**
 * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
 * etc...
 * @function
 * @since 1.3.0
 */
export declare const sortBy: <A>(ords: Ord<A>[]) => Option<Endomorphism<A[]>>;
/**
 * Non failing version of `sortBy`
 * @function
 * @since 1.3.0
 */
export declare const sortBy1: <A>(head: Ord<A>, tail: Ord<A>[]) => Endomorphism<A[]>;
export declare const array: Monad1<URI> & Foldable1<URI> & Unfoldable1<URI> & Traversable1<URI> & Alternative1<URI> & Plus1<URI> & Extend1<URI>;
