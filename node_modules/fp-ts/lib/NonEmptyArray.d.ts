import { Comonad1 } from './Comonad';
import { Foldable1 } from './Foldable';
import { Monad1 } from './Monad';
import { Option } from './Option';
import { Ord } from './Ord';
import { Semigroup } from './Semigroup';
import { Traversable1 } from './Traversable';
declare module './HKT' {
    interface URI2HKT<A> {
        NonEmptyArray: NonEmptyArray<A>;
    }
}
export declare const URI = "NonEmptyArray";
export declare type URI = typeof URI;
/**
 * Data structure which represents non-empty arrays
 * @data
 * @constructor NonEmptyArray
 * @since 1.0.0
 */
export declare class NonEmptyArray<A> {
    readonly head: A;
    readonly tail: Array<A>;
    readonly _A: A;
    readonly _URI: URI;
    constructor(head: A, tail: Array<A>);
    /**
     * Converts this {@link NonEmptyArray} to plain {@link Array}
     * @since 1.0.0
     * @example
     * assert.deepEqual(new NonEmptyArray(1, [2, 3]), [1, 2, 3])
     * @returns {Array<A>} foo
     */
    toArray(): Array<A>;
    /**
     * Concatenates this {@link NonEmptyArray} and passed {@link Array}
     * @since 1.0.0
     * @param {Array<A>} as - {@link Array}
     * @example
     * assert.deepEqual(new NonEmptyArray(1, []).concatArray([2]), new NonEmptyArray(1, [2]))
     * @returns {NonEmptyArray<A>}
     */
    concatArray(as: Array<A>): NonEmptyArray<A>;
    /**
     * Instance-bound implementation of {@link Functor}
     * @since 1.0.0
     * @param {(a: A) => B} f
     * @example
     * const double = (n: number): number => n * 2
     * assert.deepEqual(new NonEmptyArray(1, [2]).map(double), new NonEmptyArray(2, [4]))
     * @returns {NonEmptyArray<B>}
     */
    map<B>(f: (a: A) => B): NonEmptyArray<B>;
    /**
     * Instance-bound implementation of {@link Apply}
     * @since 1.0.0
     * @param {NonEmptyArray<(a: A) => B>} fab
     * @example
     * const x = new NonEmptyArray(1, [2])
     * const double = (n: number) => n * 2
     * assert.deepEqual(x.ap(new NonEmptyArray(double, [double])).toArray(), [2, 4, 2, 4])
     * @returns {NonEmptyArray<B>}
     */
    ap<B>(fab: NonEmptyArray<(a: A) => B>): NonEmptyArray<B>;
    /**
     * Same as {@link ap} but works on {@link NonEmptyArray} of functions and accepts {@link NonEmptyArray} of values instead
     * @since 1.0.0
     * @this {NonEmptyArray<(b: B) => C>}
     * @param {NonEmptyArray<B>} fb
     * @example
     * const x = new NonEmptyArray(1, [2])
     * const double = (n: number) => n * 2
     * assert.deepEqual(new NonEmptyArray(double, [double]).ap_(x).toArray(), [2, 4, 2, 4])
     * @returns {NonEmptyArray<C>}
     */
    ap_<B, C>(this: NonEmptyArray<(b: B) => C>, fb: NonEmptyArray<B>): NonEmptyArray<C>;
    /**
     * Instance-bound implementation of {@link Chain}
     * @since 1.0.0
     * @param {(a: A) => NonEmptyArray<B>} f
     * @example
     * const x = new NonEmptyArray(1, [2])
     * const f = (a: number) => new NonEmptyArray(a, [4])
     * assert.deepEqual(x.chain(f).toArray(), [1, 4, 2, 4])
     * @returns {NonEmptyArray<B>}
     */
    chain<B>(f: (a: A) => NonEmptyArray<B>): NonEmptyArray<B>;
    /**
     * Instance-bound implementation of {@link Semigroup}
     * @since 1.0.0
     * @param {NonEmptyArray<A>} y
     * @example
     * const x = new NonEmptyArray(1, [2])
     * const y = new NonEmptyArray(3, [4])
     * assert.deepEqual(x.concat(y).toArray(), [1, 2, 3, 4])
     * @returns {NonEmptyArray<A>}
     */
    concat(y: NonEmptyArray<A>): NonEmptyArray<A>;
    /**
     * Instance-bound implementation of {@link Foldable}
     * @since 1.0.0
     * @param {B} b
     * @param {(b: B, a: A) => B} f
     * @example
     * const x = new NonEmptyArray('a', ['b'])
     * assert.strictEqual(x.reduce('', (b, a) => b + a), 'ab')
     * @returns {B}
     */
    reduce<B>(b: B, f: (b: B, a: A) => B): B;
    /**
     * Instance-bound implementation of {@link Extend}
     * @since 1.0.0
     * @param {(fa: NonEmptyArray<A>) => B} f
     * @example
     * const sum = (as: NonEmptyArray<number>) => fold(monoidSum)(as.toArray())
     * assert.deepEqual(new NonEmptyArray(1, [2, 3, 4]).extend(sum), new NonEmptyArray(10, [9, 7, 4]))
     * @returns {NonEmptyArray<B>}
     */
    extend<B>(f: (fa: NonEmptyArray<A>) => B): NonEmptyArray<B>;
    /**
     * Instance-bound implementation of {@link Comonad}
     * @since 1.0.0
     * @example
     * assert.strictEqual(new NonEmptyArray(1, [2, 3]).extract(), 1)
     * @returns {A}
     */
    extract(): A;
    /**
     * Same as {@link toString}
     * @since 1.0.0
     * @returns {string}
     */
    inspect(): string;
    /**
     * Return stringified representation of this {@link NonEmptyArray}
     * @since 1.0.0
     * @returns {string}
     */
    toString(): string;
    /**
     * Gets minimum of this {@link NonEmptyArray} using specified {@link Ord} instance
     * @since 1.3.0
     * @param ord - {@link Ord} instance
     * @example
     * const minimum = new NonEmptyArray(1, [2, 3]).min(ordNumber) // 1
     * @returns {A}
     */
    min(ord: Ord<A>): A;
    /**
     * Gets maximum of this {@link NonEmptyArray} using specified {@link Ord} instance
     * @since 1.3.0
     * @param ord - {@link Ord} instance
     * @example
     * const maximum = new NonEmptyArray(1, [2, 3]).max(ordNumber) // 3
     * @returns {A}
     */
    max(ord: Ord<A>): A;
    /**
     * Gets last element of this {@link NonEmptyArray}
     * @since 1.6.0
     * @example
     * const last = new NonEmptyArray(1, [2, 3]).last(); // 3
     * const last = new NonEmptyArray(1, []).last(); // 1
     * @returns {A}
     */
    last(): A;
    /**
     * Sorts this {@link NonEmptyArray} using specified {@link Ord} instance
     * @since 1.6.0
     * @param {Ord<A>} ord - {@link Ord} instance
     * @example
     * const result = new NonEmptyArray(3, [2, 1]).sort(ordNumber)
     * const expected = new NonEmptyArray(1, [2, 3])
     * assert.deepEqual(result, expected)
     * @returns {NonEmptyArray<A>}
     */
    sort(ord: Ord<A>): NonEmptyArray<A>;
    /**
     * Reverts this {@link NonEmptyArray}
     * @since 1.6.0
     * @example
     * const result = new NonEmptyArray(1, [2, 3]).reverse()
     * const expected = new NonEmptyArray(3, [2, 1])
     * assert.deepEqual(result, expected)
     * @returns {NonEmptyArray<A>}
     */
    reverse(): NonEmptyArray<A>;
}
/**
 * Builds {@link NonEmptyArray} from {@link Array} returning {@link Option#none} or {@link Option#some} depending on amount of values in passed array
 * @function
 * @since 1.0.0
 * @param {Array<A>} as
 * @returns {Option<NonEmptyArray<A>>}
 */
export declare const fromArray: <A>(as: A[]) => Option<NonEmptyArray<A>>;
/**
 * Builds {@link Semigroup} instance for {@link NonEmptyArray} of specified type arument
 * @function
 * @since 1.0.0
 * @returns {Semigroup<NonEmptyArray<A>>}
 */
export declare const getSemigroup: <A = never>() => Semigroup<NonEmptyArray<A>>;
/**
 * @instance
 * @since 1.0.0
 */
export declare const nonEmptyArray: Monad1<URI> & Comonad1<URI> & Foldable1<URI> & Traversable1<URI>;
